<!DOCTYPE html>
<html lang="en">
  <head>
    <title>World</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        color: #fff;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        color: #fff;
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        display:block;
      }
      #info a {
        color: #046;
        font-weight: bold;
      }
    </style>
  </head>
  <body>

    <script src="./js/three.js"></script>
    <script src="./js/controls/OrbitControls.js"></script>
    <script src="./js/objects/Reflector.js"></script>
    <script src="./js/loaders/MTLLoader.js"></script>
    <script src="./js/loaders/OBJLoader.js"></script>
    <script src="./js/WebGL.js"></script>
    <script src="./js/stats.js"></script>

    <script>
      if (WEBGL.isWebGLAvailable() === false) {
        document.body.appendChild(WEBGL.getWebGLErrorMessage());
      }

      var scene, camera, renderer, exporter, mesh;
      var sqSize = 100
      var globalObjects = []
      var noClickObjects = ['Ground', 'Grid', 'FadeoutMrr', 'GndMirror', 'GndMrr']

      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();

      var stats = new Stats()
      stats.showPanel(0)
      document.body.appendChild(stats.dom)

      function createObjectItem(scene) {
        var loader = new THREE.MTLLoader()

        loader.load(
          './res/obj/1stbuilding.mtl',
          function (materials) {
            materials.preload();
            new THREE.OBJLoader()
              .setMaterials(materials).load('./res/obj/1stbuilding.obj', function (object) {
                var scale = 50
                object.scale.set(scale, scale, scale)
                object.position.x = 1300
                object.position.z = 375
                scene.add(object);
              },
              function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
              },
              function (err) {
                console.error('An error happened.', err);
              }
            )
          }
        )
      }

      init();
      animate();

      function onDocumentMouseDown(event) {
        // event.preventDefault()
        if (event.button === 0) {
          mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1
          mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1
          raycaster.setFromCamera(mouse, camera)

          var intersects = raycaster.intersectObjects(scene.children)
          for (var i = 0; i < intersects.length; i++) {
            // intersects[i].object.material.color.set(0xff0000)
            // if (noClickObjects.indexOf(intersects[i].object.name) === -1) {
            //   console.log('C-OBJ', i, intersects[i].object.geometry.name)
            // }
          }
          if (intersects.length >= 1) {
            if (noClickObjects.indexOf(intersects[0].object.name) === -1) {
              console.log('Clicked object type: ' + intersects[0].object.geometry.name)
            }
          }
        }
      }
      document.addEventListener('mousedown', onDocumentMouseDown, false)

      function rnd(min, max) {
        return Math.floor(Math.random() * max) + min
      }

      function createWebServers(count, blHeight, sqOffset) {
        var ws = []

        var oX = 0
        var oZ = 0
        if (sqOffset && typeof sqOffset === 'object') {
          oX = sqSize * sqOffset.x
          oZ = sqSize * sqOffset.z
        }

        var distance = 20
        var bX = 20 + oX
        var bZ = 20 + oZ

        var material = new THREE.MeshPhongMaterial({ color: 0x333333 });

        for (var i = 0; i < count; i++) {
          var rnd = Math.floor(Math.random() * 10) + 10
          var wsHeight = blHeight - 10 + rnd
          var wsGeo = new THREE.BoxBufferGeometry(15, wsHeight, 15)
          wsGeo.translate(0, wsHeight / 2, 0)
          wsGeo.name = 'WebSvr'
          var wsMesh = new THREE.Mesh(wsGeo, material)
          wsMesh.castShadow = false
          var heightDiff = wsHeight - blHeight

          var offset = i === 0 ? 0 : Math.floor(Math.abs(i - 1) / 2) + 1
          wsMesh.position.y = 0
          if (i === 0) {
            wsMesh.position.x = bX
            wsMesh.position.z = bZ
          } else if (i % 2 === 0) {
            wsMesh.position.x = bX + (offset * distance)
            wsMesh.position.z = bZ
          } else if (i % 2 !== 0) {
            wsMesh.position.x = bX
            wsMesh.position.z = bZ + (offset * distance)
          }
          ws[i] = wsMesh
        }
        return ws;
      }
      function createSqlDbs(count, blHeight, sqOffset) {
        var sdb = []

        var oX = 0
        var oZ = 0
        if (sqOffset && typeof sqOffset === 'object') {
          oX = sqSize * sqOffset.x
          oZ = sqSize * sqOffset.z
        }

        var distance = count === 1 ? 0 : 25
        var bX = (count === 1 ? 75 : 80) + oX
        var bZ = (count === 1 ? 75 : 80) + oZ

        var hFactor = count === 1 ? 30 : 50

        var material = new THREE.MeshPhongMaterial({ color: 0x555555 });

        for (var i = 0; i < count; i++) {
          var rnd = Math.floor(Math.random() * 10) + hFactor
          var sdbHeight = (count === 1 ? 0 : 10) + blHeight - hFactor + rnd
          var sdbGeo
          if (count === 1) {
            sdbGeo = new THREE.CylinderBufferGeometry(20, 20, sdbHeight, 17)
          } else {
            sdbGeo = new THREE.CylinderBufferGeometry(10, 10, sdbHeight, 17)
          }
          sdbGeo.translate(0, sdbHeight / 2, 0)
          sdbGeo.name = 'SqlDB'
          var sdbMesh = new THREE.Mesh(sdbGeo, material)
          sdbMesh.castShadow = false
          var heightDiff = sdbHeight - blHeight

          var offset = i === 0 ? 0 : Math.floor(Math.abs(i - 1) / 2) + 1
          sdbMesh.position.y = 0
          if (i === 0) {
            sdbMesh.position.x = bX
            sdbMesh.position.z = bZ
          } else if (i % 2 === 0) {
            sdbMesh.position.x = bX - (offset * distance)
            sdbMesh.position.z = bZ
          } else if (i % 2 !== 0) {
            sdbMesh.position.x = bX
            sdbMesh.position.z = bZ - (offset * distance)
          }
          sdb[i] = sdbMesh
        }
        return sdb;
      }
      function createNosqlDbs(count, blHeight, sqOffset) {
        var ndb = []

        var oX = 0
        var oZ = 0
        if (sqOffset && typeof sqOffset === 'object') {
          oX = sqSize * sqOffset.x
          oZ = sqSize * sqOffset.z
        }

        var distance = 15
        var bX = 20 + oX
        var bZ = 80 + oZ

        var material = new THREE.MeshPhongMaterial({ color: 0x888888 });

        for (var i = 0; i < count; i++) {
          var rnd = Math.floor(Math.random() * 10) + 35
          var ndbHeight = blHeight - 35 + rnd
          var ndbGeo = new THREE.CylinderBufferGeometry(3, 5, ndbHeight, 9)
          ndbGeo.translate(0, ndbHeight / 2, 0)
          ndbGeo.name = 'NosqlDB'
          var ndbMesh = new THREE.Mesh(ndbGeo, material)
          ndbMesh.castShadow = false
          var heightDiff = ndbHeight - blHeight

          var offset = i === 0 ? 0 : Math.floor(Math.abs(i - 1) / 2) + 1
          ndbMesh.position.y = 0
          if (i === 0) {
            ndbMesh.position.x = bX
            ndbMesh.position.z = bZ
          } else if (i % 2 === 0) {
            ndbMesh.position.x = bX + (offset * distance)
            ndbMesh.position.z = bZ - (offset * distance)
          } else if (i % 2 !== 0) {
            ndbMesh.position.x = bX + (offset * distance)
            ndbMesh.position.z = bZ
          }
          ndb[i] = ndbMesh
        }
        return ndb;
      }

      function createServer(sqOffset) {
        var webServers = createWebServers(rnd(2, 4), 75, sqOffset)
        webServers.forEach(function(itm) { scene.add(itm) })

        var sqlDbs = createSqlDbs(rnd(1, 3), 17, sqOffset)
        sqlDbs.forEach(function(itm) { scene.add(itm) })

        var nosqlDbs = createNosqlDbs(rnd(0, 4), 80, sqOffset)
        nosqlDbs.forEach(function(itm) { scene.add(itm) })

        return {
          webServer: webServers,
          sqlDb: sqlDbs,
          nosqlDb: nosqlDbs
        }
      }

      function init() {
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
        camera.position.set(1000, 1000, 1000);
        camera.translateX(500)
        camera.translateZ(1000)

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 1000, 4000);

        // ground
        var ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x333333, depthWrite: true }));
        ground.name = 'Ground'
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = false;
        ground.opacity = 0.8
        ground.translateX(500)
        ground.translateY(-500)
        scene.add(ground);
        // console.log('GND', ground.uuid)

        var geometry = new THREE.PlaneBufferGeometry(2000, 2000);
        geometry.name = 'GndMirror'
        var groundMirror = new THREE.Reflector(geometry, {
          clipBias: 0.8,
          textureWidth: window.innerWidth * window.devicePixelRatio,
          textureHeight: window.innerHeight * window.devicePixelRatio,
          color: 0x70857d,
          recursion: 1
        });
        groundMirror.name = 'GndMrr'
        groundMirror.position.y = 0.5;
        groundMirror.rotateX(-Math.PI / 2);
        groundMirror.translateX(500)
        groundMirror.translateY(-500)
        scene.add(groundMirror);
        // console.log('MIRROR', geometry.uuid, groundMirror.uuid)

        var fadeout = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshLambertMaterial({ color: 0x000802, opacity : 0.8 , transparent: true }))
        fadeout.name = 'FadeoutMrr'
        fadeout.position.y = 0.75
        fadeout.rotateX(-Math.PI / 2)
        fadeout.translateX(500)
        fadeout.translateY(-500)
        scene.add(fadeout)
        // console.log('FadeoutMRR', fadeout.uuid)

        var grid = new THREE.GridHelper(2000, 20, 0x08cc4c, 0x08cc4c);
        grid.name = 'Grid'
        grid.material.opacity = 1;
        grid.material.transparent = true;
        grid.translateX(500)
        grid.translateZ(500)
        scene.add(grid);
        // console.log('GRID', grid.uuid)

        var max = rnd(5, 30)
        console.log('Max', max)
        for(var i = 1; i < max; i++) {
          var offset = {x: rnd(0, 10), z: rnd(0, 10)}
          console.log('OFFs', offset)
          globalObjects.push(createServer(offset))
        }

        createObjectItem(scene)

        // hemiLight
        var hemiLight = new THREE.HemisphereLight(0xffffff, 0xaaaaaa);
        hemiLight.position.set(0, 1000, 0);
        scene.add(hemiLight);

        var directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(0, 200, 100);
        directionalLight.castShadow = false;
        directionalLight.shadow.camera.top = 180;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.left = -120;
        directionalLight.shadow.camera.right = 120;
        scene.add(directionalLight);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false;
        document.body.appendChild(renderer.domElement);

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(100, 100, 100);
        controls.maxPolarAngle = Math.PI / 2
        controls.update();

        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      var prev = 0
      function animate() {
        stats.begin()

        var timer = Date.now() * 0.01;
        var sec = Math.round((timer / 10 % 1) * 10)
        if (sec !== prev) {
          prev = sec
          globalObjects.forEach(function(set) {
            set.webServer.forEach(function(svr) {
              var nH = svr.scale.y
              if (Math.floor(Math.random() * 1000) > 900) {
                if (Math.floor(Math.random() * 10) >= 5) {
                  nH = 0.5 + Math.random()
                } else {
                  nH = 1 - Math.random() / 2
                }
              }
              svr.scale.set(1, nH, 1)

              if (Math.floor(Math.random() * 1000) > 990) {
                svr.material.color.setHex(0xd90900)
              }
              if (Math.floor(Math.random() * 1000) < 100) {
                svr.material.color.setHex(0x333333)
              }
            })
            set.sqlDb.forEach(function(svr) {
              var nH = svr.scale.y
              if (Math.floor(Math.random() * 1000) > 900) {
                if (Math.floor(Math.random() * 10) >= 7) {
                  nH = 0.5 + Math.random()
                } else {
                  nH = 1 - Math.random() / 2
                }
              }
              svr.scale.set(1, nH, 1)

              if (Math.floor(Math.random() * 1000) > 995) {
                svr.material.color.setHex(0xd90900)
              }
              if (Math.floor(Math.random() * 1000) < 300) {
                svr.material.color.setHex(0x555555)
              }
            })
            set.nosqlDb.forEach(function(svr) {
              var nH = svr.scale.y
              if (Math.floor(Math.random() * 1000) > 800) {
                if (Math.floor(Math.random() * 10) >= 4) {
                  nH = 0.5 + Math.random()
                } else {
                  nH = 1 - Math.random() / 2
                }
              }
              svr.scale.set(1, nH, 1)

              if (Math.floor(Math.random() * 1000) > 998) {
                svr.material.color.setHex(0xd90900)
              }
              if (Math.floor(Math.random() * 1000) < 200) {
                svr.material.color.setHex(0x888888)
              }
            })
          })
        }
        stats.end()
        requestAnimationFrame(animate);

        renderer.render(scene, camera);
      }
    </script>

  </body>
</html>
